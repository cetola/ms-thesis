\section{The Arm TrustZone Solution}
Arm released TrustZone in 2004 for their ``application capable'' cores, and only as recently as 2016 did they extend this technology to their cores designed for microcontrollers \cite{Pinto2019}. When evaluating how Arm’s TrustZone works, we must remember several important distinctions. Firstly, the Arm specifications include several different architectures with several different states. Each Arm architecture and state combination may operate slightly differently in regard to how TrustZone is implemented. This thesis will only consider the ARMv8-A architecture running in the AArch64 state. Secondly, because Arm Limited licenses their cores to hardware manufacturers, \glspl{soc} and platforms may choose to implement security in many ways, and with much more flexibility than in Intel platforms. For simplicity’s sake, our thesis will only cover firmware solutions for TrustZone implementations provided by Linaro's open source projects \gls{tfa} and \gls{optee}.
 
Arm \gls{soc} processors create a more absolute separation between the concepts of ``secure'' and ``normal or insecure'' operation than Intel \gls{sgx}. At its highest level this is accomplished using the \gls{scr} ``Non-Secure bit'' (NS) with 1 meaning non-secure and 0 meaning secure. This is perhaps the most fundamental element that separates Arm's two security worlds. Digging a bit deeper, this separation of worlds is accomplished using four separate primitives: one on the bus, one on the \gls{soc} core, one as part of the memory infrastructure, and finally one as part of the debug infrastructure.

\begin{figure}[hb]
\centering
\input{tikz/tz-hl}
\caption[High Level TrustZone Overview]{\textbf{A high level overview of Arm TrustZone layout on an SoC.} Note that unlike Intel \gls{sgx}, TrustZone is present as part of much of the SoC's platform. Reproduced as a simplified version of Figure 2-3 of the GlobalPlatform specification \cite{GlobalPlatform2018}.}
\label{fig:tz-hl}
\end{figure}

Firstly, the bus interface, called the \gls{amba} \gls{axi}, partitions all of the \gls{soc}’s hardware and software resources by taking advantage of a set of bits. Hardware logic present in this ``TrustZone-enabled AMBA3 AXI  bus fabric'' \cite{ArmBuildingSS} ensures that no ``Secure World'' resources can be accessed by ``Normal World'' components. These bits include AWPROT for write transactions and ARPROT for read transactions where like the NS bit low is Secure and high is Non-secure. 

Secondly, \gls{soc}s which include cores like the ARMv8-A, implement extensions which enable a single physical processor core to safely and efficiently execute code from both the Normal World and the Secure World in a time-sliced fashion \cite{TrustZoneExplained}. The value of the Non-Secure bit is read from the \gls{scr} and passed along down the bus to the memory controller and peripherals. A new instruction, the \gls{smc}, is added which allows the core to switch between the secure and normal modes. We will discuss the secure monitor firmware which is responsible for handling these interrupts in the next section.

Thirdly, the memory infrastructure includes security features like \gls{tzasc} and \gls{tzma} \cite{TrustZoneExplained}. The \gls{tzasc} allows for configuration of the secure and normal world memory regions. It does so by partitioning DRAM into areas which have secure world access and those regions which have normal world access. This process can only be done from the secure world. The \gls{tzma} serves a similar function for any off-chip memory such as an off-chip ROM. The way in which this memory partitioning happens is based on the specific SoC implementing TrustZone. SoC manufacturers can provide robust or simple partitioning and it is important to understand the implementation of your specific SoC's memory controller to properly understand how TrustZone has been implemented.

Lastly, the security-aware debug infrastructure controls debug access to the Secure World. This includes ``secure privileged invasive (JTAG) debug, secure privileged non-invasive (trace) debug, secure user invasive debug, and secure user non-invasive debug'' \cite{ArmBuildingSS}. By using two different signals into the core along with two different bits in a secure register, the core can report either invasive or non-invasive debug info. In this way, the core is able to debug either the normal world only, or it can debug both the secure and normal worlds together. These four primitives provide a framework or scaffolding on which to build a platform capable of secure computation.

In the next section we discuss the firmware that will implement a \gls{tee} using TrustZone's features. First, we will point out a potentially confusing difference between how Intel and Arm create privilege levels. Unlike Intel platforms which refer to their privilege levels as \glspl{ring}, Arm uses ``Exception Levels'' EL0 through EL3 \cite{armfundv8A}. Here EL3 is the highest, most privileged level where as EL0 is the lowest and least privileged level. Much like with the x86 architecture, exceptions like data aborts, prefetch aborts, and other interrupts can be taken from the level at which they occur to the same or any higher privileged level, but not a level which has less privileges. So, for example, an interrupt occurring in the OS kernel (EL1) can be handled in the kernel or in the secure monitor (EL3), but not in the lower privileged application level (EL0). Practically speaking this means that the user applications running on a system which has not been compromised will not have access to kernel or lower exceptions. Another common confusion point between Arm and Intel is that Intel's ``\gls{ring} 0'' is the highest privilege level while Arm's ``EL0'' is the lowest privilege level.

\renewcommand{\arraystretch}{2.5}
\input{tables/arm-els}

See Figure \ref{table:arm_priv_lev_map} for a complete list of privilege levels, their description, and how they might be implemented in an ARMv8-A system. Each exception level manages its own page tables and control registers with the exception of EL0 which is managed by EL1 \cite{armfundv8A}. This is a common practice across architectures where the kernel level mode controls the page table for the applications running on top of it. As we will see, this division is taken advantage of by the ARMv8-A architecture to enable the separation of memory accesses between the Secure World and the Normal World.

\section{Arm Trusted Firmware}
Since 2013, Arm, in cooperation with several other industry leaders, has provided \glsreset{tfa}\gls{tfa} as an open source reference implementation of the firmware required to develop Secure World software for A-Class devices (including ARMv8-A). \gls{tfa} provides many features including secure device initialization, modular boot flow, trusted boot, and the secure monitor that allows switching between the Normal World and the Secure World. It should be noted that all of this code and documentation is freely available online \cite{urlTrustedFirmware}. The Trusted Firmware Project is a `not for profit' open source project hosted by Linaro Limited (``Linaro'').

Arm Trusted Firmware uses the scaffolding provided by the A-Class devices to implement the key aspects of TrustZone, namely Trusted Boot and the Secure Monitor. There are currently over 30 platforms supported by Trusted Firmware and because the code is open source (BSD 3-clause), porting new platforms can be done by following many of the existing open source examples. Before we explore Arm Trusted Firmware, we must first understand how an Arm platform can be initialized in a secure state, specifically using \gls{tbb}. \gls{tbb} is based on two standards, the Arm Trusted Base System Architecture (TBSA) \cite{Edition2018} and the Arm Trusted Board Boot Requirements (TBBR) \cite{ArmTrustedBoot}. Both of these specifications are client-based solutions and it is likely that server based solutions are in development internally at Arm.

\begin{figure}[ht]
\centering
\input{tikz/tbb-flow}
\caption[Arm's Trusted Board Boot]{\textbf{A significantly simplified boot flow for setting up a secure \gls{rot} on an Arm system running Trusted Firmware.} Here we see the boot flow from a cold reset all the way to the Normal World bootloader which may load any untrusted OS kernel.}
\label{fig:tbb-flow}
\end{figure}

As soon as the SoC comes out of power-on-reset, execution happens in integrity protected memory like on-chip Boot ROM or Trusted SRAM. At this stage we have access to a \gls{rotpk} located in one of the \gls{soc}'s \gls{otp} Efuse registers. These keys are usually SHA-256 and the Efuse is burned by the manufacturer to ensure the integrity of the keys. This secure ROM firmware code is often called the Bootloader Stage 1 or BL1, and it is responsible for checking the validity of the \gls{rotpk}. Using this key, BL1 can verify the hash of the next bootloader stage (BL2). The code in BL1 is the only code that must run in EL3, minimizing the amount of initialization code that must run at this critical privilege level.

Once in BL2, the code is executing in Secure World EL2 and the firmware can use the \gls{rotpk} to extract the Trusted World \gls{rotpk} and the Normal World \gls{rotpk}, which are used in turn to validate the Secure World Trusted OS hash as well as the Normal World Untrusted OS hash. All of these keys and hashes are included as extensions to the x.509 standard format, however there is no need for a valid Certified Authority (CA) certificate, as we are verifying the contents of the certificates and not the validity of a certificate issuer. BL2 also does some RAM initialization before it passes off to BL3 where the Secure Monitor is implemented.

This Secure Monitor runs in EL3 and is responsible for loading both the Secure OS as well as the Normal World bootloader (like U-Boot or some UEFI implementation). This Secure Monitor stays resident in memory during the life of the system and will manage the interactions between the Normal and Secure Worlds. All of these stages (BL1 - BL3) of \gls{tbb} are implemented by Arm's \glsreset{tfa}\gls{tfa} reference implementation.

\begin{figure}[ht]
\makebox[\textwidth][c]{\input{tikz/tz-overview}
}\caption[Arm TrustZone Example of Normal and Secure World]{\textbf{Secure World implementation using ARM TrustZone.}
The \gls{soc} boots into the Secure World and a monitor is registered which acts as the interface between the ``secure'' and ``normal'' worlds. All EL3 exceptions are caught by the secure monitor, and there is a special EL3 exception called a ``secure monitor call'' which is used to switch the processor between the two worlds. Figure recreated and modified from the original \cite{TeschkeSGX}.
\label{fig:tz-overview}}
\end{figure}

Once the Trusted Firmware has initialized the system in a secure state, we have initialized two worlds, the Trusted World and the Normal World. It is perhaps easiest to think about the interaction between these two worlds in much the same way we think about making calls from user mode into kernel mode in Linux systems. In Linux systems, we take advantage of system calls (syscall) to bridge a trust boundary between the kernel's concerns like interacting with a network card and the user application's concerns like displaying a web page. At no point in this interaction should the user application code have access to the network card's buffers, however the kernel is able to read and write these buffers and mediate the flow of data to/from the client application. This ``guarded'' flow of data is similar to how memory in the Secure World is kept separate from the Normal World using an instruction which generates an exception called a Secure Monitor Call (SMC).

\section{TrustZone Attestation}

Local \gls{attestation} using TrustZone is dependent on several \glspl{measurement} taken during the boot process. If the boot process is not secured then ``all bets are off'', and we cannot assure the integrity or confidentiality of the code or data inside the \gls{tee}. We will follow this boot flow step by step, and each step number is illustrated in Figure \ref{fig:tz-measure}.

At power on, implicitly trusted code living in secure ROM or SRAM is executed. Since Boot Loader 1 (BL1) is responsible for authenticating the BL2 stage it verifies the \gls{rot} public key in the BL2 content certificate against the \gls{rot} public key stored in the hash (Figure \ref{fig:tz-measure} -- Step 1). BL1 then verifies the BL2 content certificate using the enclosed \gls{rot} public key (Step 2). BL1 loads BL2 into memory and verifies the hash (Step 3) and execution is transferred to BL2 (Step 4). Since BL2 is responsible for authenticating all of the possible \bltx stages (e.g. \blto, \blttw, \bltt), BL2 verifies the \gls{rot} public key in the certificate against \gls{rot} public key stored in the hash (Step 5). BL2 then verifies the certificate using its \gls{rot} public key and saves the trusted world (TW) and normal world (NW) public keys. BL2 uses the TW public key to verify the \bltx certificate (Step 6) and verifies the \bltx content certificate using the \bltx public key (Step 7). BL2 can now extract and save the \bltx hash used for \bltx image verification (Step 8). BL2 verifies the \bltt key certificate using the NW public key (Step 9) and verifies the \bltt content certificate using the \bltt pub key(Step 10). BL2 extracts and saves the \bltt hash used for \bltt image verification (Step 11). Finally, execution is transferred to verified \bltx (Step 12) and \bltt images (Step 13).

\begin{figure}[hp]
\centering
\input{tikz/tz-measure}
\caption[Arm Trusted Firmware Trusted Board Boot]{\textbf{\glsreset{tbb}\gls{tbb} flow in \glsreset{tfa}\gls{tfa}} The boot flow begins with implicitly trusted keys and code living in some secure ROM or SRAM (BL1). Each stage of the boot is then verified against the \gls{rot} public key and each bootloader stage is hash checked. All this information can be found in the Arm TBBR-CLIENT documentation \cite{ArmTrustedBoot}. This diagram and flow description were recreated from a presentation by Matteo Carlini entitled ``Secure Boot on ARM Systems: Building a Complete Chain of Trust Upon Existing Industry Standards Using Open-source Firmware''.}
\label{fig:tz-measure}
\end{figure}

We have now securely booted, and our secure monitor provided by \gls{tfa} should be loaded into \blto running in the highest privilege level of EL3. The trusted OS, \glsreset{optee}\gls{optee} is loaded into \blttw and runs at EL2. Any trusted applications will run in EL1 of the ``secure world'' built on top of this secure OS. A ``normal world'' bootloader like U-Boot or some UEFI implementation is loaded into \bltt and runs in the privilege level of EL2. An operating system like Linux or Windows can now load their kernel into memory and will operate at privilege level EL2.  Finally ``normal world'' applications can be loaded by the OS and run in privilege mode EL1. These applications can make \glspl{smc} with the \gls{optee} kernel driver in the non-secure world to act as a bridge to trusted applications running in the secure world.

\gls{optee} will load \glspl{ta} into memory when a \gls{ree} application makes a request \gls{smc} with the corresponding UUID of the \gls{ta}. These \glspl{ta} consist of a ELF binary, signed and possibly encrypted, named from the UUID of the \gls{ta}. It is the responsibly of the trusted OS to load the \glspl{ta} from the \gls{ree} file system and to check the integrity of the \glspl{ta} as part of the \gls{chain of trust}. \gls{optee} maintains a version database of all the \glspl{ta} it has loaded and checks the version of each \gls{ta} before loading. The version database prevents downgrading of the \gls{ta} to a earlier, possibly insecure version.

Since loading a \gls{ta} from the \gls{ree} file system creates an inherently larger attack surface, there are two ways for \gls{optee} to load applications from a more secure location. The first method is known as ``early \gls{ta}'' and allows applications to be linked into the data section of the \gls{tee} core blob itself. The ``early \gls{ta}'' method has two benefits: applications can be loaded from a known secure source and applications can be loaded before the normal world or its file system have been initialized. The other, more robust option is to load the application from secured storage, an \gls{optee} implementation of the GlobalPlatform specification for Trusted Storage \cite{GlobalPlatform2018}. 

\begin{figure}[ht]
\makebox[\textwidth][c]{\input{tikz/tz-attest}
}\caption[OP-TEE Chain of Trust]{\textbf{The OP-TEE Chain of Trust builds off the secure boot chain of trust.} From Figure \ref{fig:tz-measure}, we loaded the secure monitor into \blto and our secure OS, \gls{optee}, into \blttw. With that \gls{chain of trust} complete, we can now use the keys present in \gls{optee} to load trusted applications into our \gls{tee}. The \gls{tee} functions and libraries actually live in the same area and are separated here only for convenience. Parts of \gls{optee} may run in EL1 (user level privilege), however that is beyond the scope of this diagram.
\label{fig:tz-attest}}
\end{figure}

\gls{optee} secure storage follows the GlobalPlatform \gls{tee} Core API document \cite{GPD5} defining ``Trusted Storage API for Data and Keys'' in section 5. The details of \gls{optee} secure storage are beyond the scope of this thesis. The reader should understand that regardless of where the applications are loaded from, they are signed with a key from the trusted OS. \gls{optee} \glsreset{ta}\glspl{ta} are signed with the pre-generated 2048-bit RSA private key provided by the trusted OS developer as shown in Figure \ref{fig:tz-attest}. These keys should be stored in a hardware security module like a \gls{tpm}, however the security model for any given \gls{ta} is left up to the trusted OS developer. Currently, \gls{optee} only supports one private key per trusted OS. As such, each \gls{ta} will be signed with the same key. This step completes the \gls{chain of trust} and we are able to assure that each step in loading the application, from PoR to loading the application into memory, has occurred in a way which preserves the integrity and confidentiality of the data as well as the integrity of the code.

The complexity of remote attestation on mobile platforms, specifically cell phones, has been well studied and understood for over a decade \cite{nauman2010beyond}. There have been many recent efforts towards a more formally proven type of remote attestation \cite{cabodi2015formal, eldefrawy2017hydra} which can be used in IoT and embedded applications. However, Arm TrustZone as a framework leaves the implementation of remote attestation as an exercise for the platform vendor or manufacturer. We will return to this point in Chapter \ref{chap:comp} when we present a comparison of our discussed \glspl{tee}.

In this chapter, we have shown how Arm has designed a framework on which hardware manufacturers and system vendors can hang an implementation of a \gls{tee}. Unlike with Intel SGX, and perhaps core to Arm's business model, many of the implementation details are left to the manufacturer. This allows for great flexibility at the cost of engineering resources and time. Next, we will explore RISC-V \gls{pmp}, and describe a system which is open source from the ISA through to user space applications. As we will show, open source specifications allow for even greater flexibility than Arm TrustZone, though again at a greater cost.
