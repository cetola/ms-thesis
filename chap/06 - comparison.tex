\section{A Method for Comparing TEEs}
If we are to compare these or any group of \glspl{tee} we must first agree on what we are comparing. As such we define any given \gls{tee} based on a set of properties that the \gls{tee} must implement or might implement. We will make the assumption that the end goal of the comparison is to choose a \gls{tee} that best meets the needs of the system architect. As such, we must take the system architect's needs into consideration in choosing which properties that we will compare. An architect designing an embedded system with no access to networking will certainly not require remote \gls{attestation}, as an example. 

As mentioned in Chapter \ref{chap:intro}, we will use the properties of a \gls{tee} as defined by the Confidential Computing Consortium (CCC) \cite{cccTAC}. The CCC is an open source project that brings together hardware vendors, cloud providers, and software developers to accelerate the adoption of \gls{tee} technologies and standards. They define code integrity, data integrity, and data confidentiality as three required properties of any hardware \gls{tee}. All three of the \gls{tee} technologies which we have summarized in the preceding chapters provide these three required features in different ways. The CCC also discusses more advanced features like code confidentiality, authenticated launch, programmability, \gls{attestation}, and recoverability, which can be considered optional properties of a \gls{tee}. As a final option of a \gls{tee}, we will include extensibility, which will be discussed in detail shortly.

Notably absent from our list of required properties is code confidentiality. There are several reasons why one might want code to be confidential. Code may contain proprietary algorithms for machine learning or other intellectual property. Likewise code may contain information about health or safety systems which must remain confidential to assure functional safety. On the other hand, the code that runs inside the \gls{tee} may be open source, making the feature of code confidentiality counterproductive. As such, code confidentiality is considered an optional property by our definition.

By authenticated launch, we mean a mechanism by which the \gls{tee} can prevent a host application from loading, or limit its functionality based on a set of criteria or security model. One can think of this in terms of a banking application on a cell phone. If any stage of the \gls{attestation} process fails, we want to recognize that code integrity can no longer be assured. We may want to fail to load the banking application with appropriate errors if code integrity is compromised. However, we may want some of the features of the banking application available, while restricting others. Authenticated launch may restrict withdrawing funds from an account while allowing the application to provide text messaging with technical support in order to resolve the problem.

By programmability, we mean the ability of a \gls{tee} to be programmed with code that is unrestricted and able to be changed by the end user. This is apposed to a \gls{tee} with a limited set of available functions or one that is pre-programmed by the manufacturer or system vendor. Programmability will be limited by the type of instructions which are allowed to be executed from inside the \gls{tee}. The size of the region of code that is allowed to be used by the \gls{tee} may also be restricted. Lastly, the way in which code running inside the \gls{tee} is allowed to communicate with code running outside the \gls{tee} is also a consideration of programmability. We will consider a \gls{tee} programmable to different degrees based on these limitations.

By \gls{attestation}, we will use the definition by the CCC provided in Section 6 of their paper \cite{cccTAC}. The attestation workflow starts with a secure connection between the two parties, identified as the verifier and the attester. The verifier must first challenge the attester to initiate the check. The challenge from the verifier signals to the attester that it must communicate with trusted hardware to request a \gls{measurement} of the \gls{tee}. The trusted hardware is responsible for the \gls{measurement} value as well as any certification of origin. The attester can then return these values to the verifier. The verifier will check any signatures provided based on the security model. \Gls{attestation} may be performed locally on the host machine. If the verifier is on a remote machine to that of the attester we would consider that to be remote \gls{attestation}.

By recoverability, we mean a way for the \gls{tee} to ``roll back'' to some known good state should a failure occur while preforming validation on the integrity or confidentiality of the system. The goal of recoverability is to re-establish trust in the \gls{tcb}. Part of the \gls{tcb} may not be easily recoverable. For example, if the platform firmware loaded onto an Intel \gls{sgx} system is found to be untrustworthy, a simple firmware update may not be capable of removing malicious code. However, if the code running inside the \gls{sgx} enclave is found to be untrustworthy, simply reloading that code from its original source may be enough to reliably restore trust in the application.

Finally, we add extensibility as the final optional property of a \gls{tee}. Extensibility was not defined in the CCC document, however extensibility can be observed to some extent in all three \gls{tee} technologies we have covered. We define extensibility as the ability to customize the deployment and management of the \gls{tee} environment, including hardware, firmware, and software. This property comes at the cost of supporting those customizations. As the Linus's Law states, ``Given enough eyeballs, all bugs are shallow'' \cite{raymond1999cathedral}. Regardless, the burden of support for customization must be a consideration, and a healthy open source project is no small feat.

While these properties are a good starting point for analysis and comparison, we must break these properties down further in order to engage in a more rigorous comparison. Authenticated launch can be broken up into two parts: the ability to prevent application launch, or the ability to launch applications with limited functionality. Programmability will be broken into three types: the size available to the \gls{tcb}, the number of unique trusted applications one can run, and the number trusted OS's one can run to manage these applications. \Gls{attestation} can be divided into three parts, with remote attestation, local attestation, and if a hardware root of trust is available. Recoverability will be divided into system which allow: revocation of keys or other components, ability to recover the \gls{tcb} using a hardware \gls{rot}, and finally if re-issuing keys is possible without the need for re-provisioning. Extensibility will be broken up into three parts: hardware, firmware, and software. We will consider the levels of extensibility as either ``highly extensible'', ``somewhat extensible'', or ``not extensible''.

\section{Mapping Data Points}

We recommend using tables to chart the comparison of these properties we have discussed. In the following Tables \ref{tab:tee-compare}, \ref{tab:attest-compare}, and \ref{tab:ext-compare}, we give example tables for the three technologies discussed in the previous chapters. The first Table \ref{tab:tee-compare} covers all six of the optional properties of a \gls{tee} that we have discussed in this chapter. Rather than grading each implementation of the property in a simple ``good, better, best'' fashion, we list if the property is possible in the given solution, and if so,  the dependency of that property. We will remind the reader that this data can and will change drastically over time. All of these tables are meant as examples to the process of comparison and should not be considered as complete and wholly valid data sources.

Noting that the optional property of a \gls{tee} is available and required dependencies is helpful, however we also make a point to parenthetically note an example dependency where applicable. At the highest level, as in Table \ref{tab:tee-compare}, this can be quite broad indeed. For example, \gls{attestation} is possible with TrustZone and is provided locally by firmware or remotely by SoC manufacturers like Qualcomm. This is further illustrated in Table \ref{tab:attest-compare}, where we show that local \gls{attestation} can be achieved merely by using the appropriate firmware, however a system like Qualcomm's MSM8974 Snapdragon-based platform is required \cite{spensky2016sok}. Again, note that we are using quite an old example here, circa 2016. Readers wishing to implement this method of comparison would be wise to chose current security platforms. Likewise, we list Intel as the only current solution to providing remote \gls{attestation} for \gls{sgx} solutions, however it is highly likely that other solutions are available.

The final Table \ref{tab:ext-compare} compares extensibility and requires we provide context. The table works from high level features like the Software Development Kit (SDK), to low level features like the actual HDL used to generate the \gls{tee}. As mentioned earlier, extensibility does not require that the system in question be open source. However, since open source options exist, and those systems are inherently extensible, we have listed those where possible. To say that the firmware is open source and therefore extensible does not provide enough explanation. As an example, the firmware for RISC-V \gls{pmp} and Arm TrustZone provide a high level of extensibility. The trusted OS provided by \gls{optee} and secure boot provided by \gls{tfa} allow a high level of customization and extension. Likewise the Keystone project allows developers to extend its feature set with a set of ``plugable interfaces'' \cite{lee2019keystone}. While Intel and others have worked to provide open source and extensible firmware for their platforms, the goal of those firmware projects is not to provide systems with a way to extend the features provided by Intel \gls{sgx}. 

As mentioned earlier, extensible systems as described in Table \ref{tab:ext-compare} may lack vendor-supplied support options. While Intel systems may seem like the more ridged of the three options, Intel aims to provide a high level of support for their large cloud and data center customers. Providing adequate support to those customers is a delicate balance between the ability to customize Intel systems and the need to provide uniformly high quality support to those customers. One can certainly build a RISC-V system which is completely customized from the HDL to the software SDK, but the responsibility of supporting that system will lie with the entity which customized it or the open source community build up around that system.

\renewcommand{\arraystretch}{1}
\input{tables/results-comparison}

\section{Considerations and Limitations}

In this comparison we have not distinguished between platform manufacturers and platforms vendors. As an example, Supermicro is a platform manufacturer which might produce a platform based on an Intel Xeon Processor currently code named ``Ice Lake-SP'' which will support \gls{sgx} on multi-socket systems. They might then sell those platforms to a vendor like Hewlett Packard or Dell. How Intel \gls{sgx} will function on these platforms becomes a combination of the instructions Intel has added to the architecture, the workflow inherent in the microarchitecture, how the chipset is assembled, how Supermicro assembled that chipset into a platform, and how HP or Dell supports that platform with firmware, software, and possibly remote \gls{attestation} services. The same is true of Arm systems and RISC-V systems. One quickly sees the complexity of securing systems in the real world. Our method for comparison is meant only as a high level tool for assessing the appropriateness of a \gls{tee} technology to a use case.

The method we have described will also be limited by the scope of the use case. The complexity of the comparison will grow in a linear manner to the complexity of the use case. One can quickly postulate that a multi-party system based on heterogeneous \glspl{tee} will reach levels of complexity such that this method begins to break down, or at the very least requires much more rigor than the simple comparisons shown here. We submit this method not as a golden standard for comparison, but rather as a baseline on which further research may provide avenues for comparison not imagined in this thesis.