\section{A Method for Comparing TEEs}
If we are to compare these or any group of \glspl{tee} we must first agree on what we are comparing. As such we define any given \gls{tee} based on a set of properties that the \gls{tee} must implement or might implement. We will make the assumption that the end goal of the comparison is to choose a \gls{tee} that best meets the needs of the system architect. As such, we must take those needs into consideration in choosing which properties that we will compare. An architect designing an embedded system with no access to networking will certainly not require remote \gls{attestation}, as an example. 

As mentioned in Chapter \ref{chap:intro}, we will use the properties of a \gls{tee} as defined by the Confidential Computing Consortium \cite{cccTAC}, an open source project that brings together hardware vendors, cloud providers, and software developers to accelerate the adoption of \gls{tee} technologies and standards. They define code integrity, data integrity, and data confidentiality as three required properties of any hardware \gls{tee}. They also discuss more advanced features like code confidentiality, authenticated launch, programmability, \gls{attestation}, and recoverability, which can be considered optional properties of a \gls{tee}. Notably absent from our list of required properties is code confidentiality. There are several reasons why we might want our code to be confidential. It may contain proprietary algorithms for machine learning or other intellectual property. However the code that runs inside the \gls{tee} may be open source, making the feature of code confidentiality counterproductive. As such, that feature is considered an optional property by our definition.

By authenticated launch, we mean a mechanism by which the \gls{tee} can prevent a host application from loading, or limit its functionality based on a set of criteria or security model. By programmability, we mean the ability of a \gls{tee} to be programmed with code that is unrestricted and able to be changed by the end user. This is apposed to a \gls{tee} with a limited set of available functions or one that is pre-programmed by the manufacturer or system vendor. By recoverability, we mean a way for the \gls{tee} to ``roll back'' to some known good state should any of the validations performed in order to assure integrity or confidentiality fail.

While these properties are a good starting point for analysis and comparison, we must break these down further in order to engage in a more rigorous comparison. Authenticated launch can be broken up into two parts: the ability to prevent application launch, or the ability to launch applications with limited functionality. Programmability will be broken into three types: fully programmable, partially programmable, or non-programmable. \Gls{attestation} can be divided into three parts, with remote attestation, local attestation, and if a hardware root of trust is available. Recoverability will be considered. Revocation of keys or other components should cause those associate signatures to no longer be trusted. If we are able to recover the \gls{tcb} using a hardware \gls{rot} then the system is considered to be recoverable. This involves re-issuing keys from some trusted source without the need for re-provisioning.

Finally, we will add extensibility as the final property of a \gls{tee}. We define extensibility as the ability to customize the deployment and management of the \gls{tee} environment, including hardware, firmware, and software. This property comes at the cost of supporting those customizations. As the Linus's Law states, ``Given enough eyeballs, all bugs are shallow'' \cite{raymond1999cathedral}. Regardless, the burden of support for customization must be a consideration, and a healthy open source project is no small feat.

\section{Mapping Data Points}

\renewcommand{\arraystretch}{1}
\input{tables/results-comparison}

\section{Considerations and Limitations}
