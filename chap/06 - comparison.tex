\section{A Method for Comparing TEEs}
If we are to compare these or any group of \glspl{tee} we must first agree on what we are comparing. As such we define any given \gls{tee} based on a set of properties that the \gls{tee} must implement or might implement. We will make the assumption that the end goal of the comparison is to choose a \gls{tee} that best meets the needs of the system architect. As such, we must take the system architect's needs into consideration in choosing which properties that we will compare. An architect designing an embedded system with no access to networking will certainly not require remote \gls{attestation}, as an example. 

As mentioned in Chapter \ref{chap:intro}, we will use the properties of a \gls{tee} as defined by the Confidential Computing Consortium (CCC) \cite{cccTAC}. The CCC is an open source project that brings together hardware vendors, cloud providers, and software developers to accelerate the adoption of \gls{tee} technologies and standards. They define code integrity, data integrity, and data confidentiality as three required properties of any hardware \gls{tee}. All three of the \gls{tee} technologies which we have summarized in the preceding chapters provide these three required features in different ways. The CCC also discusses more advanced features like code confidentiality, authenticated launch, programmability, \gls{attestation}, and recoverability, which can be considered optional properties of a \gls{tee}. As a final option of a \gls{tee}, we will include extensibility, which will be discussed in detail shortly.

Notably absent from our list of required properties is code confidentiality. There are several reasons why one might want code to be confidential. Code may contain proprietary algorithms for machine learning or other intellectual property. Likewise code may contain information about health or safety systems which must remain confidential to assure functional safety. On the other hand, the code that runs inside the \gls{tee} may be open source, making the feature of code confidentiality counterproductive. As such, code confidentiality is considered an optional property by our definition.

By authenticated launch, we mean a mechanism by which the \gls{tee} can prevent a host application from loading, or limit its functionality based on a set of criteria or security model. One can think of this in terms of a banking application on a cell phone. If any stage of the \gls{attestation} process fails, we want to recognize that code integrity can no longer be assured. We may want to fail to load the banking application with appropriate errors if code integrity is compromised. However, we may want some of the features of the banking application available, while restricting others. Authenticated launch may restrict withdrawing funds from an account while allowing the application to provide text messaging with technical support in order to resolve the problem.

By programmability, we mean the ability of a \gls{tee} to be programmed with code that is unrestricted and able to be changed by the end user. This is apposed to a \gls{tee} with a limited set of available functions or one that is pre-programmed by the manufacturer or system vendor. Programmability will be limited by the type of instructions which are allowed to be executed from inside the \gls{tee}. The size of the region of code that is allowed to be used by the \gls{tee} may also be restricted. Lastly, the way in which code running inside the \gls{tee} is allowed to communicate with code running outside the \gls{tee} is also a consideration of programmability. We will consider a \gls{tee} programmable to different degrees based on these limitations.

By \gls{attestation}, we will use the definition by the CCC provided in Section 6 of their paper \cite{cccTAC}. The attestation workflow starts with a secure connection between the two parties, identified as the verifier and the attester. The verifier must first challenge the attester to initiate the check. The challenge from the verifier signals to the attester that it must communicate with trusted hardware to request a \gls{measurement} of the \gls{tee}. The trusted hardware is responsible for the \gls{measurement} value as well as any certification of origin. The attester can then return these values to the verifier. The verifier will check any signatures provided based on the security model. \Gls{attestation} may be performed locally on the host machine. If the verifier is on a remote machine to that of the attester we would consider that to be remote \gls{attestation}.

By recoverability, we mean a way for the \gls{tee} to ``roll back'' to some known good state should a failure occur while preforming validation on the integrity or confidentiality of the system. The goal of recoverability is to re-establish trust in the \gls{tcb}. Part of the \gls{tcb} may not be easily recoverable. For example, if the platform firmware loaded onto an Intel \gls{sgx} system is found to be untrustworthy, a simple firmware update may not be capable of removing malicious code. However, if the code running inside the \gls{sgx} enclave is found to be untrustworthy, simply reloading that code from its original source may be enough to reliably restore trust in the application.

Finally, we add extensibility as the final optional property of a \gls{tee}. Extensibility was not defined in the CCC document, however extensibility can be observed to some extent in all three \gls{tee} technologies we have covered. We define extensibility as the ability to customize the deployment and management of the \gls{tee} environment, including hardware, firmware, and software. This property comes at the cost of supporting those customizations. As the Linus's Law states, ``Given enough eyeballs, all bugs are shallow'' \cite{raymond1999cathedral}. Regardless, the burden of support for customization must be a consideration, and a healthy open source project is no small feat.

While these properties are a good starting point for analysis and comparison, we must break these properties down further in order to engage in a more rigorous comparison. Authenticated launch can be broken up into two parts: the ability to prevent application launch, or the ability to launch applications with limited functionality. Programmability will be broken into three types: the size available to the \gls{tcb}, the number of unique trusted applications one can run, and the number trusted OS's one can run to manage these applications. \Gls{attestation} can be divided into three parts, with remote attestation, local attestation, and if a hardware root of trust is available. Recoverability will be divided into system which allow: revocation of keys or other components, ability to recover the \gls{tcb} using a hardware \gls{rot}, and finally if re-issuing keys is possible without the need for re-provisioning. Extensibility will be broken up into three parts: hardware, firmware, and software. We will consider the levels of extensibility as either ``highly extensible'', ``somewhat extensible'', or ``not extensible''.

\section{Mapping Data Points}

We recommend using tables to chart the comparison of these properties we have discussed. In the following Tables \ref{tab:tee-compare}, \ref{tab:attest-compare}, and \ref{tab:recover-compare}, we give example tables for the three technologies discussed in the previous chapters. The first Table \ref{tab:tee-compare} covers all six of the optional properties of a \gls{tee} that we have discussed in this chapter. Rather than grading each implementation of the property in a simple ``good, better, best'' fashion, we list if the property is possible in the given solution, and if so,  the dependency of that property.

\renewcommand{\arraystretch}{1}
\input{tables/results-comparison}

\section{Considerations and Limitations}
