\section{Overview}
In order to understand \glspl{tee} we must first look at how computer architecture security worked before the problem of secure remote computation. The processor modes discussed in the introduction contained four \glspl{ring} with the most privileged level, \gls{ring} 0, executing operating system kernel code. However, in most modern x86 client systems there are 3 levels of even greater privilege than \gls{ring} 0. We will examine each of these briefly and describe why they do not provide the same type of protections that a \gls{tee} provides.

\section{The Predecessors of the TEE}

In 1990, Intel integrated a new privilege mode into their i386SL processor called \gls{smm} \cite{zimmer2005hardened}, now commonly referred to as ``\gls{ring} -2'' (\gls{ring} negative two).  OS code does not have access to this privilege level and only specific firmware, usually provided by the platform manufacturer, is allowed to execute code in \gls{smm}. This processor mode is entered by using a special \gls{smi}. This interrupt has the highest priority of any interrupt even to this day, and is even higher priority than a \gls{nmi}. Common tasks one might perform in \gls{smm} include thermal management, power management, or even something as simple as altering the volume output in response to buttons on a laptop keyboard \cite{yao2009system}. \gls{smm} would remain the most privileged level of code execution until the release of \gls{ime} in 2008 \cite{eldar2008configuring}.

The memory used in \gls{smm}, called \gls{smram}, is secured from any accesses or modifications originating anywhere outside \gls{smm}. Secured accesses include any accesses or modifications originating from the CPU, from I/O devices, and from \glspl{dma}. When an \gls{smi} is generated, all the CPU treads enter \gls{smm} and each of their register states are saved in a memory table inside \gls{smram}. Work can now be done by the \gls{smi} handler. Once this work is finished, each of the CPUs previous states are restored and execution is handed back to where the \gls{smi} was originally generated. Since there can be multiple \gls{smi} handlers there is firmware code that runs in a single thread and acts as an \gls{smi} dispatcher. All other CPU threads wait inside \gls{smm} until the handler thread has returned \cite{delgado2013}. This firmware code is an implementation of the \gls{uefi} specification, which is the successor to the \gls{efi} specification \cite{beyondBIOS}.

There are several reasons why \gls{smm} is not a suitable replacement for a \gls{tee}. Firstly, using \gls{smm} for any tasks which consume a significant amount of time would cause the system to hang while \glspl{smi} are handled. As such, \gls{smm} tasks are confined to small workloads which can return quickly and do not need to happen in rapid succession. These are exactly the types of tasks we wish to run in a \gls{tee}. Tasks like processing a credit card payment, or verifying the identify of the user with biometrics would all take significant time to run and would need to happen in quick succession.

Secondly, \gls{smm} is very restrictive in terms of how code is developed for the platform. All code executed in \gls{smm} must be located inside the system firmware, loaded into \gls{smram}, and locked before the OS is loaded into memory. As such, firmware code does not have easy access to communicating with the host OS but must use special \gls{efi} \gls{smm} variables \cite{uefi2020}.

Lastly, while updating firmware in the field is possible \cite{zimmer2011apparatus}, it almost always requires a reboot of the system. Updating the code in a \gls{tee} is a critical function that will be required much more often than a firmware update and should not require system reboot each time. These are just a few reasons why \gls{smm} is not a suitable solution to the problem of secure remote computation. Perhaps the overarching reason is that \gls{smm} was not designed to solve the problem of secure remote computation. Regardless, we have shown why it should not be used where a \gls{tee} would be better suited.

In 2005 \cite{uhlig2005intel}, Intel released their first processor to allow the next most privileged mode of their x86 processors, \gls{vtx}\footnote{We use the acronym \gls{vtx} here to refer to all of Intel Virtualization Technology, though in this case the ``x'' refers to Xeon processors with this feature. Non-Xeon processors would use the designation VT. There is also Intel Virtualization Technology for Directed I/O (VT-d). In this thesis we will use \gls{vtx} so as to avoid any confusion with the common acronym VT.}. Commonly referred to as ``\gls{ring} -1'' (ring negative one), \gls{vtx} added new instructions called \glspl{vms}. These instructions are used to create a layer of hardware isolation between the host OS from the guest OS. It is tempting to see a \gls{tee} as a type of virtualization. Indeed, one early form of a trusted computing environment used a ``dedicated closed virtual machine'' \cite{garfinkel2003terra} to achieve many of the goals of a modern \gls{tee}. However, as others have shown \cite{teeWhatIsIt}, this type of virtualization fails to cover several key properties of a \gls{tee}. For our purposes, we will consider these properties attestability and code confidentiality, and will discuss these in depth in coming chapters.

In 2008 \cite{eldar2008configuring}, Intel developed what is today the most privileged processor level on x86 hardware, the \glsreset{ime}\gls{ime}. This technology, commonly referred to as ``\gls{ring} -3'' (\gls{ring} negative three) is not actually a processor mode at all. It is instead a feature of some Intel chipsets. Most of the properties of \gls{ime} are obscured by the proprietary firmware that it runs. The majority of information available regarding \gls{ime} is found either in Intel's publications or from the plethora of reverse engineering done by security researchers. As such, we will not consider \gls{ime} a suitable replacement for a \gls{tee} for two key reasons: most of the information about this technology is gained by indirect means like reverse engineering and the firmware is not indented to be modified from the signed binary provided by Intel. 

These three x86 ``negative \glspl{ring}'' provide hardware protection of various kinds and each has its own restricted area of memory. However, none of these technologies serve as a viable solution to the problem of secure remote computation. It is no surprise that Intel eventually developed \gls{sgx}, their own implementation of a \gls{tee} in order to address this problem. Before we address \gls{sgx} specifically, we will continue to track the development of \glsreset{tee}\glspl{tee} by starting with their use in handsets, the precursor to today's smartphones.

\section{Birth of a TEE}

The concept of securing computation is not a new idea. As we have seen with \gls{ime}, neither is the technique of using a processor other than the main, general purpose CPU for secure computation. For almost two decades \cite{osborn2013trusted} hardware manufacturers have relied on \glspl{tpm} for a similar kind of secure computation. In 2009 the \gls{tcg} specification for a \gls{tpm} was ratified as an ISO standard. A \gls{tpm} is a system that must remain separate from the system it reports to: the host system. It can be a single physical component that communicates with the host system over a simple bus. \glspl{tpm} can have their own processor, RAM, ROM, and flash memory. While the host system cannot directly change the values of the \gls{tpm} memory, it can use the simple bus to send and receive information. As of \gls{tpm} version 2.0, the \gls{tpm} can now be a part of the main processor, however it must use hardware memory partitioning and use a well defined interface instead of the simple bus. The use of the main processor as a \gls{tpm} may add significantly more speed, but at the cost of more complexity. \glspl{tpm} contain random number generators, cryptography key generators, and secure storage.

While \glspl{tpm} have many of the features we require of our \glspl{tee}, they were designed with securing small amounts of data like cryptographic keys, not entire applications. \glspl{tpm} focus on security over speed and their cryptographic algorithms may be purposely run at much slower speeds than is possible with a CPU, let alone a cryptographic accelerator. \glspl{tpm} do, however, provide a valuable tool for a \gls{tee} to use as part of its \gls{chain of trust}\footnote{Unsurprisingly, the concept of a ``chain of trust'' comes out of electronic commerce security publications from the 1990's \cite{679731}. The internet opened up the concept of electronic commerce to a much broader audience. In doing so, it also opened up a much larger attack surface for threat models to consider.}. Concepts used in a \gls{tpm} like secure storage and isolated memory are expanded in a \gls{tee} with concepts like isolated and protected IO and isolated RAM. It is not surprising that we see the first industry efforts around \glspl{tee} around the same time that the ISO standard for \glspl{tpm} is published.

\glspl{tee} were first defined by the \gls{omtp} Hardware Working Group and ratified in 2009 \cite{Confidential2009}. This standard was designed specifically for ``handset manufacturers''. The \gls{omtp} standard was transferred to the Wholesale Applications Community (WAC) in 2010 and in July 2012 WAC itself was closed, with the \gls{omtp} standards being transferred to The GSM Association (originally Groupe Sp\'ecial Mobile) \cite{WAC}. The \gls{omtp} standard defines an ``execution environment'' as a combination of five elements: a processing unit, a bus, physical memory, a boot process, and the contents of the execution environment \cite{Confidential2009}. These contents include the code, data, and keys required for computation. The \gls{omtp} document goes on to describe two sets of security requirements which meet their definition of a \gls{tee}, called ``Profile 1 and 2''. Profile 2 provides greater security than Profile 1, however both meet their definition of a \gls{tee}.

\renewcommand{\arraystretch}{2}
\input{tables/omtp-threats}

Both profiles provide protection against unauthorized memory access given a list of vulnerable attack surfaces summarized in Table~\ref{table:omtp_threat_groups}. The core requirements for an \gls{omtp} \gls{tee} cover these ``threat groups'' to different degrees. There are 27 core requirements in total and it is out of the scope of this thesis to list or go into details on them. Sufficed to say that they address the attack surfaces described in Table~\ref{table:omtp_threat_groups}. Also, it is clear from the threat groups described that these threat models are only applicable to handsets and do not cover typical embedded devices. Another standards body called GlobalPlatform took up the task of standardizing the use of \glspl{tee} across multiple embedded platforms.

GlobalPlatform Incorporated is a nonprofit industry organization that began in 1999 with the mission of providing standardization around mobile payment devices and software. In 2011 they created a \gls{tee} model \cite{GlobalPlatform2018} that met the needs of embedded use cases. They define a \gls{tee} as a system providing ``isolated execution, integrity of \glspl{ta}, and integrity and confidentiality of \gls{ta} assets'' \cite{GlobalPlatform2018}. A GlobalPlatform \gls{tee} is more rigorous than the \gls{omtp} standard in that it requires a security certification provided by GlobalPlatform and must comply with the following GlobalPlatform standards: \gls{tee} Protection Profile, \gls{tee} Client API Specification, and \gls{tee} Internal Core API Specification \cite{GPD2, GPD3, GPD4}.

Unlike in the \gls{omtp} standard, GlobalPlatform first introduces the concept of \gls{attestation} in its definition of a \gls{rot}. We will discuss \gls{attestation} in depth for each of our technologies we cover, as well as in \autoref{chap:comp} where we consider this property of a TEE and if it can be considered optional \cite{cccTAC}. Standards and specifications from groups like \gls{omtp} and GlobalPlatforms paved the way for the creation of mobile devices capable of secure remote computation. Indeed, the smartphone revolution would only have been possible with the ability to run trusted applications allowing users to interact with financial, healthcare, and other valuable data.

\begin{figure}[htbp]
\centering
\input{tikz/gpd-tee}
\caption[GlobalPlatforms Typical Chipset Architecture]{\textbf{The board level chipset architecture of a typical mobile device.} The concept of an embedded or removable secure element allows for devices like a \gls{tpm} which may hold secure data but will not host the \gls{tee}. A \gls{tee} may reside on the SoC itself as with Arm TrustZone. However, it is possible to physically separate the \gls{tee} from the SoC and still be compliant with the GlobalPlatform model. This figure was recreated and simplified from Figure 2-1 on page 15 of the GlobalPlatform Technology TEE System Architecture Version 1.2. \cite{GlobalPlatform2018}.}
\label{fig:gpd-tee}
\end{figure}

In Figure~\ref{fig:gpd-tee} we see a very common mobile device system diagram with the possible \gls{tee} hosting components listed as both on and off chip. GlobalPlatforms differentiates between the \gls{ree} and the \glsreset{tee}\gls{tee}. The \gls{ree} focuses on extensibility and versatility whereas the \gls{tee} has only one purpose: to ``provide a safe area of the device to protect assets and execute trusted code'' \cite{GlobalPlatform2018}.  These standards were first put into use by complex \glspl{soc} with the release of processors implementing the ARM Cortex A5 core in 2012. These cores included Arm TrustZone as well as a reference firmware implementation for building secure applications. Arm TrustZone has since become the de facto standard for embedded devices as well as as Android-based mobile phones requiring a \gls{tee}. 

Up to now, we have only covered relatively simple use cases like handsets, smartphones, and embedded devices. Bridging the gap between these simple devices and desktop or server processors will require we cover the current dominant architecture in that space, namely the x86 family implemented by Intel and AMD.

\section{From Handsets to the Cloud}
In 2013 at a workshop titled Hardware and Architectural Support for Security and Privacy (HASP), Intel introduced \glsreset{sgx}\gls{sgx} for Intel architecture. \gls{sgx} is not an extension to the x86 architecture, but rather to the Intel architecture. As such, AMD developed their own solution called \gls{sev}. As mentioned previously, we will not discuss AMD \gls{sev} in this thesis as its architecture is quite different from Intel \gls{sgx}. While there are several papers published in the proceedings from the HASP 2013 workshop \cite{10.1145/2487726.2488368, 10.1145/2487726.2488370, anati2013innovative}, as well as two patents from Intel's original fillings \cite{johnson2010technique, mckeen2009method}, we will use a more recent paper by Costan \cite{Costan2016} as well as a recent whitepaper from Intel \cite{johnson2016intel} in exploring \gls{sgx}.

Intel's introduction of \gls{sgx} opened up the desktop and laptop markets to a new type of software application capable of hardware-backed secure ``enclaves''. It also gave application developers on Intel platforms the chance to utilize both local and remote \gls{attestation}, providing assurance from the vendor regarding code integrity and confidentiality. It wasn't until 2019 that Intel would make this technology available in multi-socket Xeon CPUs, opening the door for cloud providers to take advantage of \glspl{tee} on Intel platforms \cite{10.1145/3337167.3337173}.

\section{RISC-V: An Open Source TEE}
RISC-V is a popular modern architecture developed at the Parallel Computing Lab (Par Lab), which is part of the University of California at Berkeley. Perhaps the most notable thing about this architecture is that it has been developed using the same methodology as open source software. The specifications are published using a Creative Commons license, and all code examples or artifacts of the specification use permissive licenses like the BSD licenses or the Apache license \cite{UnprivIsa2019}. The work done on the RISC-V specifications is overseen by a non-profit organization called RISC-V International, an organization registered in Switzerland.

The Trusted Execution Environment Task Group of RISC-V International has developed a specification called \gls{pmp} as part of the RISC-V Privileged Specification \cite{PrivIsa2019}. RISC-V \gls{pmp} extends the concept of \gls{pma} to include multiple configurable sections of memory whose access rights can be altered by firmware running at the highest privilege level. RISC-V \gls{pmp} is certainly a very basic type of \gls{tee}, however plans to extend its capabilities have already been drafted in a new specification called \gls{epmp}. Likewise, drafts of \gls{spmp} and \gls{iopmp} are set for ratification in 2021. We will discuss all of these types of memory protection in detail in \autoref{chap:pmp}.

This chapter has given a brief background of \glsreset{tee}\glspl{tee} and we have been selective in mentioning only a few of the many examples of hardware security that influenced the development of \glspl{tee}. We have shown that any given \gls{tee} builds off the technologies of the past, even when incorporating new instructions or hardware unique to \glspl{tee}. As we will see, without technologies and standards like the \gls{tpm} ISO standard of 2009, \glspl{tee} would not have the means to perform many of the advanced features like attestation which are critical to some applications. We continue now with an overview of our three technologies for comparison: Intel \glsreset{sgx}\gls{sgx}, Arm TrustZone, and RISC-V \glsreset{pmp}\gls{pmp}.

\input{tables/security-timeline}
