\section{The RISC-V Open Source ISA}
RISC-V is the fifth generation of RISC processors, which have been in development since the 1980s at the University of California at Berkeley. Hence the name RISC-V has the ``five'' spelled out as a Roman numeral. One cannot talk about RISC-V's history without mentioning that of the MIPS ISA, which began in the same timeframe at Stanford in the 1980s. While MIPS was very popular in its own right, RISC was the inspiration for many ISAs including Sun Microsystems’ SPARC line, DEC’s Alpha line, Intel’s i860 and i960 processors, and indeed the ARM processors that most of us now carry in our pockets.

RISC-V is by no means the first open source ISA. Sun Microsystems introduced the OpenSPARC project in 2005 using the GNU Public License (GPL)\cite{anemaet2003microprocessor}. As many students of SoC architecture classes will know, the MIPS architecture was provided under an ``open use'' license in a pilot program by Wave Computing allowing its use in educational settings without licensing fees. ARM has partly opened its architecture allowing specific partners to proposed changes to the ISA they license. Many of these changes in industry practices reflect a growing need for openness in hardware. As Asanovi{\'c} notes, ``While instruction set architectures (ISAs) may be proprietary for historical or business reasons, there is no good technical reason for the lack of free, open ISAs'' \cite{asanovic2014instruction}. RISC-V is also not an example of open source hardware as there is nothing inherent in the specifications encouraging the end product to be non-proprietary. However, it is certainly an enabler for open source hardware development by facilitating the sharing of ideas in the form of ISA extensions and hardware tooling.

Care must be taken not to assume that the value found in open source software can be simply replicated in the hardware world. However, there is value to be gained for certain, and many of the same foundations underpinning open source software development as well as many of the lessons learned by those communities can be applied in hardware. Red Hat's Patent Promise and the growing problem that international regulations introduce are just two examples \cite{amye2021}. The fundamental concept of extensibility is perhaps the most obvious cross-cutting concern between open source hardware and software. Tim O'Reilly mentions the importance of extensibility to the proliferation of open source software 1990's. As O'Reilly notes, ``According to Linus Torvalds, Linux has succeeded at least in part because it followed good design principles, which allowed it to be extended in ways that he didn’t envision when he started work on the kernel. Similarly, Larry Wall explains how he created Perl in such a way that its feature-set could evolve naturally, as human languages evolve, in response to the needs of its users.'' \cite{o1999lessons}. Key to RISC-V's success will be the proliferation of open source extensions, tools, and designs that anyone can use as a platform on which to produce and launch innovative hardware.

RISC-V \gls{pmp} is developed as part of the ``TEE Task Group'' of RISC-V International. While membership in RISC-V International is required to participate in the development of specifications, membership is free for individuals and open to anyone. Specifications are developed using public mailing lists, and a review of each specification is open to a public review period before ratification. The specifications themselves are stored on a public GitHub repository where anyone can view the text during its development. RISC-V PMP was added to the Privileged ISA Specification \cite{PrivIsa2019} in 2019. Several libraries have been introduced to take advantage of this technology including: Multizone \cite{pinto2019industry}, Sanctum \cite{Costan2016a}, TIMBER-V \cite{weiser2019timber}, Mi6 \cite{bourgeat2019mi6}, and Keystone Enclave \cite{lee2019keystone, lee2020keystone, cheangverifying}. We will concentrate on Keystone Enclave as it is open source and still in active development.

\section{The RISC-V Memory Model}
RISC-V hardware threads, which are referred to in the specification as ``harts'' \cite{UnprivIsa2019}, have a byte-addressable address space of 2\textsuperscript{XLEN} bytes for all memory accesses. Here, XLEN refers to the width of a register in either 32 or 64 bits. Words are defined as having 32 bits. Halfwords are 16 bits, doublewords are 64 bits (8 bytes), and so on. The address space can be thought of as a ring, so that the last memory address is adjacent to the first. Memory instructions will simply wrap around the space ignoring that they have effectively ``walked off the end''. The specification leaves room for virtual memory by allowing for both explicit and implicit stores and loads. Chapter 3 defines the ``Zifencei'' extension, which defines a fence instruction that explicitly synchronizes writes to instruction memory and instruction fetches on the same \gls{hart}. The order in which these loads and stores happen is up to the implementation, and the rules for consistency are defined in the memory model.

The memory model of an instruction set architecture defines the values returned by a load. The main memory model for RISC-V is the \gls{rvwmo} model, ``which is designed to provide flexibility for architects to build high-performance scalable designs while simultaneously supporting a tractable programming model'' \cite{UnprivIsa2019}. There is also the ``Ztso'' extension which gives us the RISC-V Total Store Ordering (RVTSO) memory consistency model. One can think of RVTSO as the ``stronger'' model when compared to \gls{rvwmo}. We will only cover \gls{rvwmo} briefly here as knowledge of RVTSO is not required to understand \gls{pmp}, nor is a deep understanding of the \gls{rvwmo} required.

The microarchitecture implementing any given memory model is only required by the architecture to follow the memory model rules set forth in the model. This model does not set any other regulation on how the implementation achieves those rules, be the implementation speculative or not, in order or out of order, multithreaded or not, etc. As such, the \gls{rvwmo} starts by defining a set of primitives it uses to define the model. The base primitives are load and store, defined in Chapter 8 which covers the ``A'' Standard Extension for Atomic Instructions \cite{UnprivIsa2019}. It then uses a combination of \gls{axiomatic} and \gls{operational} semantics to define how memory consistency should be achieved.

The memory model defines the syntactic dependencies of memory operations. This is essentially a way to understand what the differences are between memory operations and the instructions which generate those operations. The memory model then defines thirteen rules that allow for the program order of each \gls{hart} to be consistent with the global order of all operations, called the ``preserved program order''. The rules cover overlapping address ordering, explicit synchronization, syntactic dependencies, and pipeline dependencies. The model then defines three axioms: the Load Value Axiom, the Atomicity Axiom, and the Progress Axiom. Any implementation which follows the \gls{rvwmo} memory model must conform to the thirteen rules and satisfy the three axioms.

\section{RISC-V Physical Memory Protection}
\section{Keystone Enclave}
\section{The future of RISC-V Memory Protection}