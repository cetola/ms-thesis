\section{Overview}
In order to understand \glspl{tee} we must first look at how computer architecture security worked before the problem of secure remote computation. The processor modes discussed in the introduction contained four protection rings with the most privileged level, ring 0, executing operating system kernel code. However, in most modern x86 client systems there are 3 levels of even greater privilege than ring 0. We will examine each of these briefly and describe why they do not provide the same type of protections that a \gls{tee} provides.

\section{The Predecessors of the TEE}

In 1990, Intel integrated a new privilege mode into their i386SL processor called \gls{smm}, \cite{zimmer2005hardened} now commonly referred to as ``ring -2'' (ring negitive two).  OS code does not have access to this privilege level and only specific firmware, usually provided by the platform manufacturer, is allowed to execute code in \gls{smm}. This processor mode is entered by using a special \gls{smi}. This interrupt has the highest priority of any interrupt even to this day, and is even higher priority than a \gls{nmi}. Common tasks one might perform in \gls{smm} include thermal management, power management, or even something as simple as altering the volume output in response to buttons on a laptop keyboard. \cite{yao2009system} \gls{smm} would remain the most privileged level of code execution until the release of \gls{ime} in 2008. \cite{eldar2008configuring}

The memory used in \gls{smm}, called \gls{smram}, is secured from any accesses or modifications originating anywhere outside \gls{smm}. This includes accesses or modifications from the CPU, from I/O devices, and from \glspl{dma}. When a \gls{smi} is generated, all the CPU treads enter \gls{smm} and each of their register states are saved in a memory table inside \gls{smram}. Work can now be done by the \gls{smi} handler. Once this work is finished, each of the CPUs previous states are restored and execution is handed back to where the \gls{smi} was originally generated. Since there can be multiple \gls{smi} handlers there is firmware code that runs in a single thread and acts as a \gls{smi} dispatcher. All other CPU threads wait inside \gls{smm} until the handler thread has returned. \cite{delgado2013} This firmware code is an implementation of the \gls{uefi} specification, which is the successor to the \gls{efi} specification. \cite{beyondBIOS}

There are several reasons why \gls{smm} is not a suitable replacement for a \gls{tee}. Firstly, using \gls{smm} for any tasks which consume a significant amount of time would cause the system to hang while \glspl{smi} are handled. As such, \gls{smm} tasks are confined to small workloads which can return quickly and do not need to happen in rapid succession. These are exactly the types of tasks we wish to run in a \gls{tee}. Tasks like processing a credit card payment, or verifying the identify of the user with biometrics would all take significant time to run and would need to happen in quick succession.

Secondly, \gls{smm} is very restrictive in terms of how code is developed for the platform. All code executed in \gls{smm} must be located inside the system firmware, loaded into \gls{smram}, and locked before the OS is loaded into memory. As such, firmware code does not have easy access to communicating with the host OS outside special \gls{efi} \gls{smm} variables. \cite{uefi2020}

Lastly, while updating firmware in the field is possible, \cite{zimmer2011apparatus} it almost always requires a reboot of the system. Updating the code in a \gls{tee} is a critical function and will be required much more often than a firmware update. These are just a few reasons why \gls{smm} is not a suitable solution to the problem of secure remote computation. Perhaps the overarching reason is the \gls{smm} was not designed to solve the problem of secure remote computation. Regardless, we have shown why it should not be used where a \gls{tee} would be better suited.

In 2005, \cite{uhlig2005intel} Intel released their first processor to allow the next most privileged mode of their x86 processors, \gls{vtx}. Commonly referred to as ``ring -1'' (ring negative one), \gls{vtx} added new instructions called \glspl{vms}. These instructions are used to create a layer of hardware isolation between the host OS from the guest OS. It is tempting to see a \gls{tee} as a type of virtualization. Indeed, one early form of a trusted computing environment used a ``dedicated closed virtual machine'' \cite{garfinkel2003terra} to achieve many of the goals of a modern \gls{tee}. However, as others have shown, \cite{teeWhatIsIt} this type of virtualization fails to cover several key properties of a \gls{tee}. For our purposes, we will consider these properties attestability and code confidentiality, and will discuss these in depth in coming chapters.

In 2008, \cite{eldar2008configuring} Intel developed what is today the most privileged processor level on x86 hardware, the \glsreset{ime}\gls{ime}. This technology, commonly referred to as ``ring -3'' (ring negative three) is not actually a processor mode at all. It is instead a feature of some Intel chipsets. Most of its features are obscured by the custom proprietary firmware that it runs, and the only information available regarding this technology is found either in Intel's publications or from the plethora of reverse engineering done by security researchers and hobbyists alike. As such, we will not consider \gls{ime} a suitable replacement for a \gls{tee} for two key reasons: most of the information about this technology is gained by indirect means like reverse engineering and the firmware is not indented to be modified from the signed binary provided by Intel. 

These three x86 ``negative rings'' provide hardware protection of various kinds and each has its own restricted area of memory. However, none of these technologies serve as a viable solution to the problem of secure remote computation. It is no surprise that Intel eventually developed \gls{sgx}, their own implementation of a \gls{tee} in order to address this problem. Before we address \gls{sgx} specifically, we will continue to track the development of \glsreset{tee}\glspl{tee} by starting with their use in handsets, the precursor to today's smartphones.

\section{Birth of a TEE}

\glspl{tee} were first defined by the \gls{omtp} and ratified in 2009 \cite{Confidential2009} specifically for ``handset manufacturers''. The \gls{omtp} standard was transferred to the Wholesale Applications Community (WAC) in 2010 and in July 2012 WAC itself was closed, with the \gls{omtp} standards being transferred to The GSM Association (originally Groupe Sp\'ecial Mobile). \cite{WAC} The \gls{omtp} defines an ``execution environment'' as a combination of five elements: a processing unit, a bus, physical memory, a boot process, and the contents of the execution environment. \cite{Confidential2009} These contents include the code, data, and keys required for computation. The \gls{omtp} document goes on to describe two sets of security requirements which meet their definition of a \gls{tee}, called ``Profile 1 and 2''. Profile 2 provides greater security than Profile 1, however both meet their definition of a \gls{tee}.

\renewcommand{\arraystretch}{2}
\input{tables/omtp-threats}

Both profiles provide protection against unauthorized memory access given a list of vulnerable attack surfaces summarized in table~\ref{table:omtp_threat_groups}. The core requirements for an \gls{omtp} \gls{tee} cover these ``threat groups'' to different degrees. There are 27 core requirements in total, and it is out of the scope of this thesis to list or go into details on them. Sufficed to say that they address the attack surfaces described in table ~\ref{table:omtp_threat_groups}. Also, it is clear from the threat groups described that these threat models are only applicable to handsets and do not cover typical embedded devices. 

GlobalPlatform Incorporated is a nonprofit industry organization that begin in 1999 with the mission of providing standardization around mobile payment devices and software. In 2011 they created a \gls{tee} model \cite{GlobalPlatform2018} that met the needs of embedded use cases. They define a \gls{tee} as a system providing ``isolated execution, integrity of \glspl{ta}, and integrity and confidentiality of \gls{ta} assets''. \cite{GlobalPlatform2018} A GlobalPlatform \gls{tee} is more rigorous than the \gls{omtp} standard in that it requires a security certification provided by GlobalPlatform and must comply with the following GlobalPlatform standards: \gls{tee} Protection Profile, \gls{tee} Client API Specification, and \gls{tee} Internal Core API Specification. \cite{GPD2}\cite{GPD3}\cite{GPD4}

Standards and specifications from groups like \gls{omtp} and GlobalPlatforms paved the way for the creation of mobile devices capable of secure remote computation. Indeed, the smartphone revolution would only have been possible with the ability to run trusted applications allowing users to interact with financial, healthcare, and other valuable data.

\begin{figure}[htbp]
\centering
\input{tikz/gpd-tee}
\caption[GlobalPlatforms Typical Chipset Architecture]{\textbf{Depicts the board level chipset architecture of a typical mobile device.} Recreated and simplified from figure 2-1 on page 15 of the GlobalPlatform Technology TEE System Architecture Version 1.2. \cite{GlobalPlatform2018}}
\label{fig:gpd-tee}
\end{figure}

In figure~\ref{fig:gpd-tee} we see a very common mobile device system diagram with the possible \gls{tee} hosting components listed as both on and off chip. GlobalPlatforms differentiates between the \gls{ree} and the \glsreset{tee}\gls{tee}. The \gls{ree} focuses on extensibility and versatility whereas the \gls{tee} has only one purpose: to ``provide a safe area of the device to protect assets and execute trusted code''. \cite{GlobalPlatform2018} These standards were first put into use by complex \glspl{soc} with the release of processors implementing the ARM Cortex A5 core in 2012. Up to now, we have only covered relatively simple use cases like handsets, smartphones, and embedded devices. Bridging the gap between these simple devices and desktop or server processors will require we cover the dominant processors in that space, namely Intel and AMD.

\section{From Handsets to the Cloud}

\section{RISC-V: An Open Source TEE}
\gls{spmp}, \gls{epmp}, \gls{iopmp}, and \gls{pmp}.

\input{tables/security-timeline}
